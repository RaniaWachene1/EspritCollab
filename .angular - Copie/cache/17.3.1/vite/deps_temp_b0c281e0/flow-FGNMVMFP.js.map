{
  "version": 3,
  "sources": ["../../../../../node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js", "../../../../../node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js", "../../../../../node_modules/@lit-labs/virtualizer/layouts/flow.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport class SizeCache {\n    constructor(config) {\n        this._map = new Map();\n        this._roundAverageSize = false;\n        this.totalSize = 0;\n        if (config?.roundAverageSize === true) {\n            this._roundAverageSize = true;\n        }\n    }\n    set(index, value) {\n        const prev = this._map.get(index) || 0;\n        this._map.set(index, value);\n        this.totalSize += value - prev;\n    }\n    get averageSize() {\n        if (this._map.size > 0) {\n            const average = this.totalSize / this._map.size;\n            return this._roundAverageSize ? Math.round(average) : average;\n        }\n        return 0;\n    }\n    getSize(index) {\n        return this._map.get(index);\n    }\n    clear() {\n        this._map.clear();\n        this.totalSize = 0;\n    }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    _getDefaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    constructor(hostSink, config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        this.totalScrollSize = { width: 0, height: 0 };\n        this.offsetWithinScroller = { left: 0, top: 0 };\n        /**\n         * Flag for debouncing asynchronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        this._pin = null;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._items = [];\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._hostSink = hostSink;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._getDefaultConfig()));\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get items() {\n        return this._items;\n    }\n    set items(items) {\n        this._setItems(items);\n    }\n    _setItems(items) {\n        if (items !== this._items) {\n            this._items = items;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        const change = Math.abs(oldPos - this._scrollPosition);\n        if (change >= 1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    set pin(options) {\n        this._pin = options;\n        this._triggerReflow();\n    }\n    get pin() {\n        if (this._pin !== null) {\n            const { index, block } = this._pin;\n            return {\n                index: Math.max(0, Math.min(index, this.items.length - 1)),\n                block,\n            };\n        }\n        return null;\n    }\n    _clampScrollPosition(val) {\n        return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n    }\n    unpin() {\n        if (this._pin !== null) {\n            this._sendUnpinnedMessage();\n            this._pin = null;\n        }\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        this._sendStateChangedMessage();\n    }\n    /**\n     * If we are supposed to be pinned to a particular\n     * item or set of coordinates, we set `_scrollPosition`\n     * accordingly and adjust `_scrollError` as needed\n     * so that the virtualizer can keep the scroll\n     * position in the DOM in sync\n     */\n    _setPositionFromPin() {\n        if (this.pin !== null) {\n            const lastScrollPosition = this._scrollPosition;\n            const { index, block } = this.pin;\n            this._scrollPosition =\n                this._calculateScrollIntoViewPosition({\n                    index,\n                    block: block || 'start',\n                }) - this.offsetWithinScroller[this._positionDim];\n            this._scrollError = lastScrollPosition - this._scrollPosition;\n        }\n    }\n    /**\n     * Calculate the coordinates to scroll to, given\n     * a request to scroll to the element at a specific\n     * index.\n     *\n     * Supports the same positioning options (`start`,\n     * `center`, `end`, `nearest`) as the standard\n     * `Element.scrollIntoView()` method, but currently\n     * only considers the provided value in the `block`\n     * dimension, since we don't yet have any layouts\n     * that support virtualization in two dimensions.\n     */\n    _calculateScrollIntoViewPosition(options) {\n        const { block } = options;\n        const index = Math.min(this.items.length, Math.max(0, options.index));\n        const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n        let scrollPosition = itemStartPosition;\n        if (block !== 'start') {\n            const itemSize = this._getItemSize(index)[this._sizeDim];\n            if (block === 'center') {\n                scrollPosition =\n                    itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n            }\n            else {\n                const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n                if (block === 'end') {\n                    scrollPosition = itemEndPosition;\n                }\n                else {\n                    // block === 'nearest'\n                    const currentScrollPosition = this._scrollPosition;\n                    scrollPosition =\n                        Math.abs(currentScrollPosition - itemStartPosition) <\n                            Math.abs(currentScrollPosition - itemEndPosition)\n                            ? itemStartPosition\n                            : itemEndPosition;\n                }\n            }\n        }\n        scrollPosition += this.offsetWithinScroller[this._positionDim];\n        return this._clampScrollPosition(scrollPosition);\n    }\n    getScrollIntoViewCoordinates(options) {\n        return {\n            [this._positionDim]: this._calculateScrollIntoViewPosition(options),\n        };\n    }\n    _sendUnpinnedMessage() {\n        this._hostSink({\n            type: 'unpinned',\n        });\n    }\n    _sendVisibilityChangedMessage() {\n        this._hostSink({\n            type: 'visibilityChanged',\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        });\n    }\n    _sendStateChangedMessage() {\n        const childPositions = new Map();\n        if (this._first !== -1 && this._last !== -1) {\n            for (let idx = this._first; idx <= this._last; idx++) {\n                childPositions.set(idx, this._getItemPosition(idx));\n            }\n        }\n        const message = {\n            type: 'stateChanged',\n            scrollSize: {\n                [this._sizeDim]: this._scrollSize,\n                [this._secondarySizeDim]: null,\n            },\n            range: {\n                first: this._first,\n                last: this._last,\n                firstVisible: this._firstVisible,\n                lastVisible: this._lastVisible,\n            },\n            childPositions,\n        };\n        if (this._scrollError) {\n            message.scrollError = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this._scrollError = 0;\n        }\n        this._hostSink(message);\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n            else {\n                this._updateVisibleIndices({ emit: true });\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._sendVisibilityChangedMessage();\n            }\n        }\n    }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = this._metricsCache.get(k)?.[leadingMargin(direction)] || 0;\n            const b = this._metricsCache.get(k - 1)?.[trailingMargin(direction)] || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    _estimatePosition(idx) {\n        const c = this._metricsCache;\n        if (this._first === -1 || this._last === -1) {\n            return (c.averageMarginSize +\n                idx * (c.averageMarginSize + this._getAverageSize()));\n        }\n        else {\n            if (idx < this._first) {\n                const delta = this._first - idx;\n                const refItem = this._getPhysicalItem(this._first);\n                return (refItem.pos -\n                    (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n                    (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize));\n            }\n            else {\n                const delta = idx - this._last;\n                const refItem = this._getPhysicalItem(this._last);\n                return (refItem.pos +\n                    (c.getChildSize(this._last) || c.averageChildSize) +\n                    (c.getMarginSize(this._last) || c.averageMarginSize) +\n                    delta * (c.averageChildSize + c.averageMarginSize));\n            }\n        }\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? this._metricsCache.getMarginSize(0) ?? averageMarginSize\n            : item\n                ? item.pos\n                : this._estimatePosition(idx);\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this.items.length - 1;\n        }\n        return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this.items.length === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a pinned item, we anchor on it\n        if (this.pin !== null) {\n            const { index } = this.pin;\n            this._anchorIdx = index;\n            this._anchorPos = this._getPosition(index);\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = this._metricsCache.getMarginSize(this._anchorIdx) ??\n            this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = this._metricsCache.getMarginSize(this._anchorIdx + 1) ??\n            this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this.items.length - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this.items.length - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this.items.length - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this.items.length - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    _reflow() {\n        const { _first, _last } = this;\n        super._reflow();\n        if ((this._first === -1 && this._last == -1) ||\n            (this._first === _first && this._last === _last)) {\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -(this._metricsCache.getLeadingMarginValue(idx, this.direction) ??\n                this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        return {\n            [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._metricsCache.clear();\n        this._scheduleReflow();\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
