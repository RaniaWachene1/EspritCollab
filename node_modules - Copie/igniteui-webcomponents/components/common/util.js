export const partNameMap = (partNameInfo) => {
    return Object.keys(partNameInfo)
        .filter((key) => partNameInfo[key])
        .join(' ');
};
export const asPercent = (part, whole) => (part / whole) * 100;
export const clamp = (number, min, max) => Math.max(min, Math.min(number, max));
export function getOffset(element, parent) {
    const { top, left, bottom, right } = element.getBoundingClientRect();
    const { top: pTop, left: pLeft, bottom: pBottom, right: pRight, } = parent.getBoundingClientRect();
    return {
        top: Math.round(top - pTop),
        left: Math.round(left - pLeft),
        right: Math.round(right - pRight),
        bottom: Math.round(bottom - pBottom),
    };
}
export function createCounter() {
    let i = 0;
    return function () {
        i++;
        return i;
    };
}
export function isLTR(element) {
    return getComputedStyle(element).getPropertyValue('direction') === 'ltr';
}
export function format(template, ...params) {
    return template.replace(/{(\d+)}/g, function (match, index) {
        if (index >= params.length) {
            return match;
        }
        const value = params[index];
        if (typeof value !== 'number' && !value) {
            return '';
        }
        return value;
    });
}
export function asNumber(value, fallback = 0) {
    const parsed = parseFloat(value);
    return isNaN(parsed) ? fallback : parsed;
}
export function wrap(min, max, value) {
    if (value < min) {
        return max;
    }
    else if (value > max) {
        return min;
    }
    return value;
}
export function isDefined(value) {
    return value !== undefined;
}
export function* iterNodes(root, whatToShow, filter) {
    if (!isDefined(globalThis.document)) {
        return;
    }
    const iter = globalThis.document.createTreeWalker(root, NodeFilter[whatToShow ?? 'SHOW_ALL']);
    let node;
    while ((node = iter.nextNode())) {
        if (filter) {
            if (filter(node)) {
                yield node;
            }
        }
        else {
            yield node;
        }
    }
}
export function getElementByIdFromRoot(root, id) {
    return root.getRootNode().getElementById(id);
}
export function isElement(node) {
    return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;
}
export function getElementsFromEventPath(event) {
    return event.composedPath().filter((item) => isElement(item));
}
export function findElementFromEventPath(predicate, event) {
    const func = typeof predicate === 'string'
        ? (e) => e.matches(predicate)
        : (e) => predicate(e);
    return getElementsFromEventPath(event).find(func);
}
export function groupBy(array, key) {
    const result = {};
    const _get = typeof key === 'function' ? key : (item) => item[key];
    for (const item of array) {
        const category = _get(item);
        const group = result[category];
        Array.isArray(group) ? group.push(item) : (result[category] = [item]);
    }
    return result;
}
//# sourceMappingURL=util.js.map